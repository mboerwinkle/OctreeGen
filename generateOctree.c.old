#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "structures.h"

double resolution = 1;
extern int cubeTriangleIntersect(double* center, double sideLen, facet triangle);
model generateOctree(model target){//based on cubealgo.txt
	//initialize values
	target.myTree = NULL;
	float* min = target.min;
	float* max = target.max;
	for(int dim = 0; dim < 3; dim++){
		min[dim] = 0;
		max[dim] = 0;
	}
	for(int fIdx = 0; fIdx < target.facetCount; fIdx++){
		float* p1 = target.facets[fIdx].p1;
		float* p2 = target.facets[fIdx].p2;
		float* p3 = target.facets[fIdx].p3;
		for(int dim = 0; dim < 3; dim++){
			if(p1[dim] < min[dim]) min[dim] = p1[dim];
			if(p1[dim] > max[dim]) max[dim] = p1[dim];
			if(p2[dim] < min[dim]) min[dim] = p2[dim];
			if(p2[dim] > max[dim]) max[dim] = p2[dim];
			if(p3[dim] < min[dim]) min[dim] = p3[dim];
			if(p3[dim] > max[dim]) max[dim] = p3[dim];
		}
	}
	printf("min: %f %f %f\nmax: %f %f %f\n", min[0],min[1],min[2], max[0],max[1],max[2]);
	double greatest = 0;
	for(int dim = 0; dim < 3; dim++){
		if(-min[dim] > greatest) greatest = -min[dim];
		if(max[dim] > greatest) greatest = max[dim];
	}
	printf("greatest: %lf\n", greatest);
	greatest/=resolution;//greatest divided by resolution so we can ignore resolution from now on
	int magnitude = 0;//magnitude 0 is a single cube centered on the origin. This never exists because we require a 1 block buffer around all objects, which cannot exist with a single block (unless the model is empty - autocheck FIXME)
	while(greatest*2+1 > 1<<magnitude){//multiply greatest by 2 because maximum magnitude cube is centered on the origin. +1 for the buffer.
		magnitude++;
	}
	printf("magnitude: %d\n", magnitude);
	int sideLength = 1<<magnitude;
	if(sideLength >= 2097100){//just ~(2^63)^(1/3)
		puts("Volume Overflows long int");
	}
	long int volume = sideLength*sideLength*sideLength;
	printf("sideLength: %d\nvolume: %ld\n", sideLength, volume);
	uint8_t *voxel = (uint8_t*)malloc(volume/8+1);
	memset(voxel, 0, volume/8+1);
	//find boundary
	for(int x = 0; x < sideLength; x++){
		for(int y = 0; y < sideLength; y++){
			for(int z = 0; z <  sideLength; z++){
				double center[3] = {((double)x), (double)y, ((double)z)};
				for(int dim = 0; dim < 3; dim++){
					center[dim]*= resolution;//scale
					center[dim]+= resolution/2.0;//center of cube
					center[dim]-= ((double)sideLength)/2.0;//center around origin
				}
				if(z%20 == 0)printf("trying %d %d %d\n", x, y, z);
				for(int tFacet = 0; tFacet < target.facetCount; tFacet++){
					if(cubeTriangleIntersect(center, resolution/2.0, target.facets[tFacet])){
						long int idx = x+y*sideLength+z*sideLength*sideLength;
						printf("intersect %ld\n", idx);
						break;
					}
				}
			}
		}
	}
	puts("Done finding border");
	//fill exterior
	//fill interior
	//create octree
	free(voxel);
	return target;
}
